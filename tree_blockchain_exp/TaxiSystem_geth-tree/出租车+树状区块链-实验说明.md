# geth1复现过程
## 1. genesisgtrie.json  复制到TaxiSystem文件夹下
## 2. 启动区块链
/home/zc/go/src/github.com/ethereum/go-ethereum/build/bin/geth1 --identity "MyEth" --rpc --rpcaddr 127.0.0.1  --rpcport "8545" --rpccorsdomain "*" --datadir gethdata --port "30303" --nodiscover --rpcapi "eth,net,personal,web3" --networkid 91036 init genesisgtrie.json

/home/zc/go/src/github.com/ethereum/go-ethereum/build/bin/geth1 --datadir ./gethdata --networkid 91036 --port 30303 --rpc --rpcaddr 127.0.0.1 --rpcport 8545 --rpcapi 'personal,net,eth,web3,admin' --rpccorsdomain='*' --ws --wsaddr='localhost' --wsport 8546 --wsorigins='*' --wsapi 'personal,net,eth,web3,admin' --nodiscover --allow-insecure-unlock --dev.period 1 --syncmode='full' console
## 3. 命令行账户生成和解锁

创建账户
```js
for (i = 0; i < 8; i++) { personal.newAccount("123456") }
```

解锁账户：

```js
for (i = 0; i < eth.accounts.length; i++) { personal.unlockAccount(eth.accounts[i],"123456",500000) }
```

将生成的账户复制到genesisgtrie.json中,完成账户余额初始化

在打开的控制台中输入`exit`退出控制台，然后删除目录`TaxiSystem/gethdata/geth`。随后，再运行一次初始化区块链和启动区块链的代码。此时，所有账户应该都有余额了。可以用`eth.geBalance(账户地址)`来检查余额：

```js
for (i = 0; i < eth.accounts.length; i++) { console.log(eth.getBalance(eth.accounts[i])) }
```

## 4. 合约部署
miner.start(1)
miner.stop()

### StoreMapContract地址
Contract mined! Address: 0x405a5bd342ca3c6223c79eaaf909d889843bcf1a
### StoreTraffic地址
Contract mined! Address: 0xc4bfb5fc9f904e6bc016ac55a4e13dbca234921d

## 5. 上传地图

在仓库的`TaxiSystem/cjz_upload`路径下找到`uploadmap_cjz_3.json`文件，打开并修改一下其中的内容：

```js
// -- snip --

// contract address 
var myContractInstance = MyContract.at("StoreMap合约的地址");
var account = "eth.accounts[0]的内容";

// -- snip --
```
令区块链开始挖矿之后，使用`node`运行一下这个脚本。终端中不断输出，直至出现“地图数据上传完成”字样。停止挖矿。

## 6. 更改文件以加入账户信息

目前，我们已经创建了8个账户。接下来，我们修改一些文件的内容，让这8个账户中的其中一个作为车辆的账户，一个作为乘客的账户。后续的自动化测试脚本，将会调用我们在本节修改的文件。

在仓库的`TaxiSystem/cjz_upload`路径下，找到如下文件并修改之：

### passengerAccounts.py

将其改为：

```python
passengers = ["eth.accounts[0]的内容"]

```

### vehicleAccounts.py

将其改为：

```python
vehicles = ["eth.accounts[1]的内容"]

```

### mapContract.js

将其改为：

```js
var mapContractAddress = "StoreMap合约的地址";
// --snip--
```
### trafficContract.js

将其改为：

```js
var trafficContractAddress = "StoreTraffic合约的地址";
```
### passengers.js

将其改为：

```js
let passengers = [
    {
        passengerId: "eth.accounts[0]的内容",
        passengerPosition: "wx4er3tvs9s",
        passengerStart: "wx4er2juseu",
        passengerEnd: "wx4g200hxgf",
    }
    // {
    //     passengerId: "0xbae4e5086ea1c75d20e9771de4b4252af4adc406",
    //     passengerPosition: "wx4er2juseu",
    //     passengerStart: "wx4epqtgstu",
    //     passengerEnd: "wx4g0n85xvf",
    // },
    // {
    //     passengerId: "0xecfc0932a92863f7c6444fb3aaff69856a189b59",
    //     passengerPosition: "wx4epqtgstu",
    //     passengerStart: "wx4epmjfu8h",
    //     passengerEnd: "wx4g0j04zb4",
    // },
    // {
    //     passengerId: "0xd382727be67e57fe18e0401fcf39686b5063ed55",
    //     passengerPosition: "wx4epmjfu8h",
    //     passengerStart: "wx4ep7tcudh",
    //     passengerEnd: "wx4g0581zf4",
    // },
]

```

## vehicles.js

将其改为：

```js
let vehicles = [
    { "vehicleId": "eth.accounts[1]的内容", "vehiclePosition": "wx4enge9c6j" }
    // { "vehicleId": "0x7c1e3c84f6eb6736181eb3edd7e8685ff960fe35", "vehiclePosition": "wx4env5dc2j" },
    // { "vehicleId": "0xf0efa2e97b9caf2155a973b30d11a36893e8988d", "vehiclePosition": "wx4enyee9mv" },
    // { "vehicleId": "0x471882a68b4fcce65aa8a12e77b6934adbe89aed", "vehiclePosition": "wx4eqb5s97v" }
]
```

在`TaxiSystem/cjz_upload`中启动终端，执行：

```bash
python3 vehicle_test.py
```

出现错误 ImportError: No module named 'selenium'
解决方法:
1. 安装pip
确认python版本
python3 --version

我的是python3,会返回版本信息
然后安装对应的pip
sudo apt install python3-pip

安装检测
pip3 --version
返回版本信息

2. 安装selenium
sudo pip3 --default-timeout=100 install https://files.pythonhosted.org/packages/ed/9c/9030520bf6ff0b4c98988448a93c04fcbd5b13cd9520074d8ed53569ccfe/selenium-3.141.0.tar.gz

安装成功

3. 更新firefox
下载新版本的firefox,目前版本72.0.2

4. 安装geckodriver
根据版本要求,下载geckodriver-v0.26.0-linux64.tar.gz
sudo tar -xvf geckodriver-v0.26.0-linux64.tar.gz
sudo mv geckodriver /usr/local/bin/
cd /usr/local/bin/
/usr/local/bin$ sudo chmod +x geckodriver
/usr/local/bin$ geckodriver

在`TaxiSystem/cjz_upload`中启动终端，执行：

```bash
python3 vehicle_test.py
```
这里根据使用的firefox浏览器做了修改

成功显示了sys_vehicle_region.html页面

# geth-tree实现过程
## 1个父链,2个子链(每个子链有一个叶子节点,共2个节点;叶子节点负责挖矿和发送交易)
使用的父链w1和两个子链w11和w12都是之前资产转移实验使用的节点信息
### 多链启动
### 解锁账户
由于存在账户,这里不再重复申请

### 在w11中部署合约

在tracts_abi_w11.txt中找到对应的内容,复制在控制台中
1. 注意发送交易的账户应该是挖矿账户(这里是accounts[2])
2. 注意交易位置,需要在w11范围内
开始挖矿，并留意输出：
miner.start(1)
miner.stop()

(在相同区块链中,相同合约部署的地址相同)
#### StoreMapContract地址
Contract mined! Address: 0x92d9f82c71009d41798ff50b30062e32af6fbe48
#### StoreTraffic地址
Contract mined! Address: 0x8ad578108e14cdd7faa383763a3bc0e746582fb8

#### 上传地图

在仓库的`cjz_upload`路径下找到`uploadmap_w11.js`文件，打开并修改一下其中的内容：

```js
// -- snip --

// contract address 
var myContractInstance = MyContract.at("StoreMap合约的地址");
var account = "eth.accounts[2]的内容";

// -- snip --
```

注意其中发送交易的位置position需要为w11范围,不然无法打包交易

令区块链开始挖矿之后，使用`node`运行一下这个脚本。终端中不断输出，直至出现“地图数据上传完成”字样。停止挖矿。

#### 更改文件以加入账户信息

我们已经创建了10个移动账户。接下来，我们修改一些文件的内容，让这10个账户中的其中一个作为车辆的账户，一个作为乘客的账户。后续的自动化测试脚本，将会调用我们在本节修改的文件。

由于移动账户在w11和w12两个子链中都有,注意不要选重复账户

在仓库的`cjz_upload`路径下，找到如下文件并修改之：

##### passengerAccounts_w11.py

将其改为：

```python
passengers = ["macc1的内容"]

```

##### vehicleAccounts_w11.py

将其改为：

```python
vehicles = ["macc2的内容"]

```

##### mapContract_w11.js

将其改为：

```js
var mapContractAddress = "w11_StoreMap合约的地址";
// --snip--
```
##### trafficContract_w11.js

将其改为：

```js
var trafficContractAddress = "w_11StoreTraffic合约的地址";
```
##### passengers_w11.js

将其改为：

```js
let passengers = [
    {
        passengerId: "macc1的内容",
        passengerPosition: "wx4er3tvs9s",
        passengerStart: "wx4er2juseu",
        passengerEnd: "wx4g200hxgf",
    }
    // {
    //     passengerId: "0xbae4e5086ea1c75d20e9771de4b4252af4adc406",
    //     passengerPosition: "wx4er2juseu",
    //     passengerStart: "wx4epqtgstu",
    //     passengerEnd: "wx4g0n85xvf",
    // },
    // {
    //     passengerId: "0xecfc0932a92863f7c6444fb3aaff69856a189b59",
    //     passengerPosition: "wx4epqtgstu",
    //     passengerStart: "wx4epmjfu8h",
    //     passengerEnd: "wx4g0j04zb4",
    // },
    // {
    //     passengerId: "0xd382727be67e57fe18e0401fcf39686b5063ed55",
    //     passengerPosition: "wx4epmjfu8h",
    //     passengerStart: "wx4ep7tcudh",
    //     passengerEnd: "wx4g0581zf4",
    // },
]

```

##### vehicles_w11.js

将其改为：

```js
let vehicles = [
    { "vehicleId": "macc2的内容", "vehiclePosition": "wx4enge9c6j" }
    // { "vehicleId": "0x7c1e3c84f6eb6736181eb3edd7e8685ff960fe35", "vehiclePosition": "wx4env5dc2j" },
    // { "vehicleId": "0xf0efa2e97b9caf2155a973b30d11a36893e8988d", "vehiclePosition": "wx4enyee9mv" },
    // { "vehicleId": "0x471882a68b4fcce65aa8a12e77b6934adbe89aed", "vehiclePosition": "wx4eqb5s97v" }
]
```

在`cjz_upload`中启动终端，执行：

```bash
python3 vehicle_test_w11.py

显示界面

### 在w12中部署合约

在tracts_abi_w12.txt中找到对应的内容,复制在控制台中
1. 注意发送交易的账户应该是挖矿账户(这里是accounts[2])
2. 注意交易位置,需要在w12范围内
开始挖矿，并留意输出：
miner.start(1)
miner.stop()

(在相同区块链中,相同合约部署的地址相同)
#### StoreMapContract地址
Contract mined! Address: 0x2d52ddd4ada5041f1f52bbbdb66d661aea96d491
#### StoreTraffic地址
Contract mined! Address: 0x06dac95f663afa961f40ab42cb1a4432707547c0

## 5. 上传地图

在仓库的`cjz_upload`路径下找到`uploadmap_w12.js`文件，打开并修改一下其中的内容：

```js
// -- snip --

// contract address 
var myContractInstance = MyContract.at("StoreMap合约的地址");
var account = "eth.accounts[2]的内容";

// -- snip --
```

注意其中发送交易的位置position需要为w12范围,不然无法打包交易

令区块链开始挖矿之后，使用`node`运行一下这个脚本。终端中不断输出，直至出现“地图数据上传完成”字样。停止挖矿。




