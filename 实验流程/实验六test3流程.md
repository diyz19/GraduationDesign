# 乘客端：

1. 上传起点与目的地
2. 获取邻居信息，通过父链获取邻居的合约地址（待实现），现操作是直接在终端确定好了相应合约地址，（上传自身position，按顺序调用合约的getVehicle），返回符合要求的车辆并判断是否跨链
   
   这一过程的理论实现是，初始定个dis值，判断初始position周围的dis为半径的圆是否进入了别的邻居区域，若进入，则调用该邻居区域的合约调用函数getVehicle，汇总结果，得到最近的车辆及其账户。（现实现是调用邻居合约地址搜索一个区块内的最近的车辆即调用）

3. 选择车辆等待确认（这一步触发异步机制，同时只有同一个乘客可以选择一个车辆），若不跨链，则简单发送交易，若跨链，则下简述跨链的操作
4. 触发跨链交易的过程：
   1. 乘客端触发车辆位置的合约的发送转账交易函数，车辆接收到该函数后，车辆端向父链账户发送一个request请求
   2. 上面的函数send成功后（未触发error），乘客端合约触发MatchOUT函数，同时发送一个事件，乘客端向父链发送一个matchout转账请求
   3. 乘客端接收到matchout事件后，调用车辆位置的合约的MatchIN函数，同时发送一个事件，车辆接收到该事件后，父链账户向车辆端发送一个matchin转账请求
   4. 上面的函数send成功后（未触发error），即此时MatchOUT和MatchIN都成功之后，车辆端合约均发送一个事件，并记录交易结果到区块链上
5. 接收到该交易完成事件后，此时彻底完成了匹配工作，上车启程---->到达目的地后结束


# 车辆端：

1. 上传初始位置
2. 有乘客请求，对应上述第三步
3. 接收到上述第四步事件后
4. 规划路线---->前往出发点等待上车
5. 乘客是否上车，对应上述第五步
6. 若上车，则规划路线---->达到后置为空车

后续需要资产回流的操作