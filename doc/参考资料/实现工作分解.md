# 实现工作任务分解

### 1 支持区域状态查询的地理位置区块链

根据物理特性区块链树的方案设计，将实现工作做如下分解。

1. 添加区块类型。为了构建树状结构，首先要完成区块分类。
   1. 修改位置：区块头。
   2. 添加内容：区块类型，平行链指针，同层级头分支区块标记。
      1. 添加数据结构。
      2. 添加区块类型赋值功能。功能依赖：区块类型赋值时需要->节点类型，节点功能，分支区块作为特定区块存储
2. 添加账户位置树。账户添加物理位置后，需要能够按照时间顺序查询。（完成）
   1. 修改位置：外部账户的账户状态。
   2. 添加内容：按照时间顺序存储账户物理位置。
3. 添加区域状态树。方便按照物理区域划分的区块链数据的查询和统计。
   1. 修改位置：区块头，trie结构，状态存储和数据库存储。
   2. 添加内容：
      1. 区块头中添加区域状态树根哈希。（完成）
      2. 添加geohash划分的GHT树状存储结构（参考MPT形式，建立新的树状存储结构,包括trie,node,迭代,同步，证明，编码，存储等）。建立ghtrie包，并对建立内容独立测试（添加对应功能的test）（完成）
      3. 状态存储中添加区域内的账户列表（accountIDList）,交易列表（TXIDList）,收据列表（RPIDList）,上层区域状态树根节点列表（URRList）。（完成）
         1. 各个区域内应该包括多个账户，交易和收据内容，要存储为list形式以保存多个数据。（完成）
         2. 功能依赖：URRList这里的填入内容需要根据不同区域的节点确定。（目前未存数据）
      4. 建立区域状态数据库RStateDB(参考StateDB),区域状态修改位置参考worldstate的修改位置。(commitNewWork->mainLoop->WriteBlockWithState)（完成）
         1. 增加regionstate部分，实现RStateDB功能。（完成）
         2. 外部实现区域状态修改。（完成）
      5. 增加数据库存储数据库增加区域状态读写。(schema.go增加前缀->database.go树写入底层数据库,参考commit)（完成）
      6. 调用中补充区域状态树。（完成）
   3. 修改思考：
      1. geohash编码时分支节点有33个字段，前32个对遍历中的前32个半字节的每一个可能值。第33个字段存储分支结束标志。在上层节点中，区域状态树只会缓存部分结构，最底层的叶子节点则不会出现。这里的结束表示说明缓存内容到这一层结束。结束标志可以和hashnode相结合。hashnode是暂时未加载节点，添加结束标志，说明在这里不用加载。
         1. 功能依赖：在这里，是否添加结束标志和添加位置，都需要依赖节点类型和节点所在geohash范围。
      2. 节点定义参考以太坊黄皮书中对MPT的定义方式。
      3. TryGet中有对key的计算，我们的方案中采用geohash作为key，不需要再次编码
4. 添加子链标志。区块中添加子链标志（geoid）,用geohash表示。

   1. 区块链启动，增加geoid标志。

   2. 数据库存储，存储内容的前缀增加geoid

   3. 区块同步和原来一致。(根据geoid，相同geoid或者geoid为共同前缀同步全部数据；否则，只同步区块头)

   4. 子链获取状态数据，只读取指定geoid区块的内容。


### 2 树状多链

目标：根据Geohash划分地理分区，不同地理分区内的节点保存不同的链上数据和本地缓存，实现数据存储的减少、吞吐量的提高以及区域状态查询效率的提高。

多链（固定结构），跨链（分步骤实现）

#### 2.1 实验设计

1. 场景设计。
   1. 物理位置区块链场景。4个交易节点分别在指定区域内移动并发送连续位置交易；1个矿工节点负责打包交易，采用全分区索引方式；1个查询节点负责在每个查询周期内采用区域索引方式查询区域状态。
   2. 树状多链场景。两层区块链结构，1个全区域区块链（BCglobal），4个子区域区块链(BC1，BC2，BC3，BC4)。全区域区块链中有1个全区域节点，负责汇总所有子链信息；4个交易节点，负责发送连续位置交易；1个查询节点负责在不同区块链的每个查询周期内查询指定区域的区域状态。

2. 实验内容。
   1. 构建时间。相同内容、相同交易数量的交易打包成功时间。
   2. 数据量。分链上数据量和数据库数据量两部分。树状区块链中交易节点分别属于1个、2个、4个子区域的数据量和物理位置区块链数据量对比。
   3. 吞吐量。树状区块链中交易节点分别属于1个、2个、4个子区域的吞吐量和物理位置区块链吞吐量对比。
   4. 查询时间。分全分区查询和子区域查询两种。树状区块链中交易节点分别属于1个、2个、4个子区域的查询时间和物理位置区块链的查询时间对比。

#### 2.2 工作分解  

1. 区块分类。（前面完成部分内容）按照genesis方式创建，后续扩展后可以同步。

2. 添加节点分类。根据功能划分不同节点类型：根节点、分支节点和叶节点。
   1. 修改位置：node，p2p，download
   2. 添加内容：
      1. 设定子链标记。
         1. 修改networkID为geohash编码。
         2. networkID有几个固定值已占用（1，2，3，4，5，1337），需要修改为非geohash合法字符（a1,a2,a3,a4,a5,a1337）,即不会进入对应网络状态中。
      2. 功能接口：节点每次进入区块链时，设定regionID，根据regionID长度判断节点类型。设定叶子节点的geohash编码为6位；根节点regionID为"A"。
   
3. 添加节点同步类型。
   1. 同步节点选择。叶节点（应该是叶子区块链的根节点，是结构节点，车辆节点是普通节点）只能同步networkID完全相同的节点的数据；分支节点可以同步前缀相同的叶节点或分支节点的数据；根节点可以同步任意节点数据。（同步哪些内容）
   2. 节点数据同步。（在原有的全节点和轻节点之外，添加不同类型节点的同步模式->tree）
      1. 功能依赖：full,fast->eth/downloader ->modes.go(分类),light->les模块
      2. 邻居查找。
         1. 修改对等节点查找方式为按照物理距离查找。
         2. 分支节点维护邻居列表，存储链内最新更新的3个邻居信息。
   3. 节点状态同步。延迟同步。同步状态标志。
   
4. 按照节点类型和区域建立区域状态树缓存和上层区域状态摘要（URRList）。
   1. 功能依赖：分支节点的区域状态缓存需要依赖区域状态树结构的完成。
   2. 增加节点间区域状态数据同步和更新功能。
   3. 功能依赖：server->table->udp->bucket->node
   4. 添加内容：URRList本地缓存
   5. 功能接口：URRList查询，
   6. 修改思考：
      1. 同步数据的full模式下，同步区块头，区块体并重放区块中的交易以生成状态数据、收据数据。fast模式下，同步所有的区块头，区块体以及状态数据，但不对区块中的交易进行重放，只会对区块中的数据进行校验。新的同步模式，需要根据计算能力和传递速度共同决定是同步更多的数据，还是重新计算更多。
   
5. 修改数据库存储。
   1. 写入数据库的数据添加regionID标志。
   2. 上层区域状态摘要跟随区域状态树写入数据库。
   
6. 车辆节点进入新区块链范围。
   1. 需要完成新链位置记录和旧链移出记录。
   2. 数据库存储内容只增加不减少。
   3. 区块头只增加不减少。
   4. 叶子节点只保留所在区域的区块体。
   
7. 增加资产转移交易。

   1. 增加资产转出交易、资产转入交易和资产转移结果确认交易，用于来源链和目标链不同的转移动作。

8. 增加父链节点跨链交易缓存记录。

   1. 记录资产管理账户

   2. 记录跨链交易的内容和状态

#### 2.3 新的实现过程
##### 拆分为独立多链
1. 叶子区块链之间的同步,regionid相同时，可以同步完整数据(√)
 1. 只有分支区块的同步(√)
 2. 只有普通区块的同步(√)
 3. 分支区块和普通区块同时同步(√)
 4. 先同步分支区块,再同步后续生成的普通区块(√)
 5. 节点退出后再次同步(√)
2. 分支节点的同步(√)
 1. 分支节点获取上层父分支节点的分支区块
 2. 分支节点同步一个叶子节点的分支区块(√)
 3. 分支节点同步不同叶子区块链的分支区块(√)
 4. 分支节点同步叶子区块链的区块头数据(√)
   1. 一个branchnode,两个leafnode:
    1. banchnode创建branchblock1;
    2. leafnode2通过addPeer添加branchnode,获得branchblock1;leafnode2创建branchblock2;
    3. leafnode3通过addPeer添加branchnode,获得branchblock1;leafnode3创建branchblock3;
    4. branchnode等待同步时间,分别获得branchblock2,branchblock3;
    5. leafnode2,leafnode3分别生成普通区块,banchnode交替接收成功;
    6. leafnode2通过removePeer移除banchnode后,产生普通区块(CBm-CBn),之后再次通过addPeer添加branchnode,普通区块可以同步成功;
    7. leafnode3不受影响
  2. 一个branchnode,一个leafnode:在leafnode移除banchnode后,再次连接banchnode可以同步普通区块
    1. 原因1:branchnode少了获得待同步区块数据的函数
    2. 原因2:在commit待同步区块前,未对commit状态赋初值

3. 叶子节点和分支节点同步
 1. 叶子节点根据regionid同步分支节点中regionid对应分支区块,以及该分支节点的所有结构父区块(√)
 2. 叶子节点不同步分支节点的普通区块(√)
4. 分支区块通过数据库存取
 1. 自己创建的可以存取(√)
 2. 获取其他节点的分支区块可以存取(√)
5. 分支节点数据库中保存所有叶子区块链的区块头，并在数据库中按照regionid独立保存，保证各个叶子区块链数据的独立性（进行中）
6. 根节点在数据库中保存完整的树状多链数据，各个子链在数据库中也是按照regionid独立保存
7. 数据库中的区块，区块头，状态数据按照regionid独立存储（进行中）
 1. 一个branchnode,一个leafnode:可以访问到正确的regionstate信息
 2. 一个branchnode,两个leafnode:为branchnode建立独立的merged regionstate,构建独立merged gtrie,可以查询到合并后的状态信息
 3. 目前只建立了account的查询,还未建立tx和receipt的合并查询
8. 节点启动步骤
 1. 先启动分支节点,分支节点建立分支区块
 2. 启动叶子节点,首先同步分支节点的分支区块,然后建立自己的分支区块
 3. 叶子节点同步叶子节点内容
##### 增加分支同步方式
1. 同步直接子链的区块头，td比较时只比较相同regionid的子链部分；(√)
2. 相同regionid的分支节点采用fastsync方式同步(√)
3. 分支节点缓存所有叶子区域状态数据的汇总区域状态树(√)
###### merged_regionstate功能测试
1. 同一子链内,两个节点数据同步和查询
 1. 第一个节点建立branchblock并负责挖矿,第二个节点可以同步成功
2. 不同子链的两个节点数据同步和查询
 1. 两节点互不影响,各自独立存储和查询
3. 一个branchnode,2个子链节点数据同步和查询
 1. 2个子链各自有一个交易时,branchnode可以查询合并区域和分支区域,子链节点可以查询各自区域
 2. 2个子链各自有5个交易时,branchnode可以查询合并区域和分支区域,子链节点可以查询各自区域
4. 一个branchnode,4个子链节点数据同步和查询
 1. 4个子链各自有5个交易时,branchnode可以查询合并区域和分支区域,子链节点可以查询各自区域
5. 1个geohash编码为1位的branchnode(bn_w),2个geohash编码为2位的branchnode(bn_w2,bn_w3)
 1. bn_w2,bn_w3下面分别有1个leafnode(ln_w21,ln_w31),bn_w,bn_w2,bn_w3功能正确
 2. bn_w2,bn_w3下面分别有2个leafnode(ln_w21,ln_w31,ln_w22,ln_w32),bn_w,bn_w2,bn_w3功能正确 
#### 跨链
##### 功能测试
1. 1个branchnode,2个子链节点.branchnode的分支账户为BA,移动账户M从A链转移至B链,首先在A链将余额转入BA,然后在B链将余额从BA转出至移动账户M中.
 1. 在A链将余额转入BA没问题,但是转出需要在分支节点发起,还有问题
   1. 建立资产转移交易类型(转出,转入,结果记录)
   1. 分支账户BA发起转入交易,根据交易类型和交易位置,由子链B接收并完成打包工作
   1. 一次资产转移工作由branchnode的一个账户完成
##### 步骤分解
1. 增加账户位置判断（来源链）(√)
2. 增加跨链资产转移请求交易TX_request（from:CN1,to:AMA,hashed:CN1_hashvalue）（目标链）(账户根据位置加入新子链,主动在目标链发起该交易)(Txtype==1)
3. 增加活跃链查询方法（父链逐层向上）(父链收到TX_request,开始查询;若未查询到,则向上层父链查询直到根节点或者查询成功)(这个可以用web3实现,)
 1. 添加账户活跃链查询方法
4. 增加跨链身份验证（只能向相同账户ID转入资产）
5. 增加资产转出交易(from:CN1,to:AMA_out,value:CN1.balance,location:AMA_out_location,hashed:CN1_hashvalue)(Txtype==2)
6. 增加资产转入交易（from:AMA_in,to:CN1,value:acc_value,location:AMA_in_location,hashed:CN1_hashvalue,exdata:rlp(out_data))(Txtype==3)
7. 增加资产转移状态记录交易（from:AMA_out,to:CN1,value:CN1.balance,exdata:rlp(in_data)）(Txtype==4)
8. 增加资产转移列表（父链，记录资产转移状态）(参考txpool方式)(√)
 1. 资产转移列表以待转移账户ID为key,一个账户同一时间只能完成一次资产转移;当资产转移列表中没有待转移交易,则可再次发起转移.
 2. 资产转移列表的pending中首先加入TX_trans交易,获得账户ID,TX_trans,来源链.
 3. 检测到TX_request交易后,和资产转移列表中的已有element匹配,将TX_request,目标链,开始时间填入对应element中.
 4. 检测到Tx_in交易后,将对应element的result改为success.
 5. 在指定valid_time内未收到Tx_in交易,将对应element的result改为fail,将element转入queue中
  1. 来源链为Tx_trans_chian,目标链为Tx_request_chain,开始时间为Tx_request_time,trans_value和req_value为资产转移身份验证
      



# 特征分析

1. 构建符合geohash划分方式的树状区块链结构
2. 具备位置信息的账户、交易和区块，构建账户位置树。每个账户具备位置信息，可以查询历史位置。 交易中的位置信息即为交易发生的物理位置，用于验证和更新节点位置。区块中添加区域状态树根，保证数据安全。
3. 区域状态树。构建以geohash为索引的改进的MPT结构GHT，每个geohash索引下以时间顺序建立账户列表（accountIDList）,交易列表（TXIDList）,收据列表（RPIDList）。优化了MPT查询方式，使其支持详细查询和模糊查询。
4. region设定。由于交易发生在最底层子区块链中，则region设定应该是当前子链的region（根据geohash编码长度和区域大小，选择5位geohash（小于25km^2），当设定交易所属区域时，选择6位geohash编码区域（小于1km^2））。
   2. 详细查询。根据region设定的geohash编码长度查询区域状态信息。
5. 前缀查询。MPT结构只支持固定长度的key查询。为了方便汇总区域状态，同时不影响区块链数据安全性。建立模糊查询方式，可以查询geohash编码长度为1-5位的汇总区域状态。

# 实验参考

1. （吞吐率）交易数量（tps，和比特币7tps、以太坊25tps比较）（分区域，并发执行）

2. 交易确认时间（比特币600s和以太坊25s）

3. 构建时间对比（添加regionstate前后的区块生成时间对比，说明没有增加时间（或增加的少））

   查询时间对比（添加regionstate前后查询region内容时间对比，说明查询时间缩短的多）

   4. 传统没有位置查询，我们的有位置，且性能提高
   5. 交易提交到确认的时间，区块构建时间，吞吐率，查询时间
   6. 宏观路况场景。（目前设定各个区域没有交互，只有节点跨区域，没有交易跨区域）
   7. 安全性，隐私性分析。
   8. 安全性由区块链结构保证。引入的位置信息对安全性的影响。

      2. 隐私性。车辆隐私数据只能自己访问，或者去隐私化访问。其他车辆无法访问隐私数据。车辆历史位置信息只有自己可以访问。

4. 假设一个距离延迟，设定固定节点数目。对比节点距离都很远，和节点都在一个区域内的交易确认时间。

   # 场景设定

![](G:/BlockChain2017/doc/跨链交易/20210323-实验场景设定.png)

场景设定：电动车充电。

1. 智能合约。
   1. 充电合约。充电申请；充电申请结果；充电站空闲结果。
   2. 信誉合约。位置信誉；排队信誉。
2. 简单流程。
   1. 充电站位置注册，充电桩数量注册。
   2. 电动车注册。
   3. 初始状态。v1充电中，占用E1。充电站状态：忙=1，闲=1，预约=0.
   4. v2状态。
      1. v2发送充电申请。
      2. v2收到申请结果，预约E2成功。
      3. 充电站状态变更：忙=1，闲=1，预约=1。
   5. v3状态。
      1. v3发送充电申请。
      2. v3收到申请结果，预约E1成功。
      3. 充电站状态变更：忙=1，闲=1，预约=2。
      4. v3超出预约时限，取消预约。
      5. 充电站状态变更：忙=1，闲=1，预约=1。
      6. v3信誉值-1

